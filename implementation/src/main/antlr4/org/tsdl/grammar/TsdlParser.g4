parser grammar TsdlParser;

options
{
  tokenVocab = TsdlLexer;
}

tsdlQuery
  :  whitespace
       (samplesDeclaration mandatoryWhitespace)?
       (filtersDeclaration mandatoryWhitespace)?
       (eventsDeclaration mandatoryWhitespace)?
       (chooseDeclaration mandatoryWhitespace)?
       yieldDeclaration whitespace
       EOF // include EOF (generated by lexer at end of source input) to ensure there is no unparsed content left
  ;

samplesDeclaration
  :  SAMPLES_CLAUSE COLON mandatoryWhitespace aggregatorsDeclarationStatement
  ;

eventsDeclaration
  :  EVENTS_CLAUSE COLON mandatoryWhitespace eventsDeclarationStatement
  ;

eventsDeclarationStatement
  :  eventList
  ;

eventList
  :  events COMMA whitespace eventDeclaration     // either two or more events
  |  eventDeclaration                           // or exactly one
  ;

events
  :  eventDeclaration (COMMA whitespace eventDeclaration)*   // one event plus [0..n] additional events
  ;

eventDeclaration
  :  filterConnective whitespace (durationSpecification whitespace)? identifierDeclaration
  ;

durationSpecification
  : DURATION_FOR mandatoryWhitespace DURATION_RANGE mandatoryWhitespace TIME_UNIT
  ;

chooseDeclaration
  :  CHOOSE_CLAUSE COLON mandatoryWhitespace choiceStatement
  ;

choiceStatement
  :  IDENTIFIER mandatoryWhitespace TEMPORAL_RELATION mandatoryWhitespace IDENTIFIER
  ;

yieldDeclaration
  :  YIELD COLON mandatoryWhitespace yieldType
  ;

yieldType
  :  YIELD_ALL_PERIODS
  |  YIELD_LONGEST_PERIOD
  |  YIELD_SHORTEST_PERIOD
  |  YIELD_DATA_POINTS
  |  YIELD_SAMPLE mandatoryWhitespace IDENTIFIER
  |  YIELD_SAMPLE_SET mandatoryWhitespace identifierList
  ;

filtersDeclaration
  :  FILTER_CLAUSE COLON mandatoryWhitespace filterConnective
  ;

filterConnective
  :  CONNECTIVE_IDENTIFIER PARENTHESIS_OPEN whitespace singlePointFilterList whitespace PARENTHESIS_CLOSE
  ;

aggregatorsDeclarationStatement
  :  aggregatorList
  ;

aggregatorList
  :  aggregators aggregatorSeparator aggregatorDeclaration      // either two or more aggregators
  |  aggregatorDeclaration                                      // or exactly one
  ;

aggregators
  :  aggregatorDeclaration (aggregatorSeparator aggregatorDeclaration)*    // one aggregator plus [0..n] additional aggregators
  ;

aggregatorDeclaration
  :  aggregatorFunctionDeclaration whitespace identifierDeclaration (whitespace echoStatement)?
  ;

echoStatement
  :  ECHO_ARROW whitespace ECHO_LABEL whitespace PARENTHESIS_OPEN whitespace echoArgumentList? whitespace PARENTHESIS_CLOSE
  ;

echoArgumentList
  :  echoArguments COMMA whitespace echoArgument      // either two or more echo arguments
  |  echoArgument                                          // or exactly one
  ;

echoArguments
  :  echoArgument (COMMA whitespace echoArgument)*    // one echo argument plus [0..n] additional arguments
  ;

identifierList
  :  identifiers COMMA whitespace IDENTIFIER      // either two or more identifiers
  |  IDENTIFIER                                       // or exactly one
  ;

identifiers
  :  IDENTIFIER (COMMA whitespace IDENTIFIER)*    // one aggregator plus [0..n] additional aggregators
  ;

aggregatorFunctionDeclaration
  :  AGGREGATOR_FUNCTION PARENTHESIS_OPEN whitespace timeRange? whitespace PARENTHESIS_CLOSE
  ;

aggregatorSeparator
  :  COMMA whitespace
  ;

timeRange
  :  STRING_LITERAL timeRangeSeparator STRING_LITERAL  // expected: ISO-8601 UTC timestamp, e.g. '2011-12-03T10:15:30.123+04:00' (to be validated by application)
  ;

timeRangeSeparator
  :  whitespace COMMA whitespace
  ;

identifierDeclaration
  :  AS whitespace IDENTIFIER
  ;

echoArgument
  :  ECHO_ARGUMENT
  |  IDENTIFIER
  |  NUMBER
  ;

singlePointFilterList
  :  singlePointFilters COMMA whitespace singlePointFilterDeclaration     // either two or more parameters
  |  singlePointFilterDeclaration                                        // or exactly one
  ;

singlePointFilters
  :  singlePointFilterDeclaration (COMMA whitespace singlePointFilterDeclaration)* // one parameter plus [0..n] additional parameters
  ;

singlePointFilterDeclaration
  :  singlePointFilter
  |  negatedSinglePointFilter
  ;

singlePointFilter
  :  valueThresholdFilter
  |  temporalFilter
  ;

negatedSinglePointFilter
  :  CONNECTIVE_NOT PARENTHESIS_OPEN whitespace singlePointFilter whitespace PARENTHESIS_CLOSE
  ;

// filter argument: STRING_LITERAL; ISO-8601 UTC timestamp, e.g. '2011-12-03T10:15:30+04:00' (to be validated by application)
temporalFilter
  :  TEMPORAL_FILTER_TYPE PARENTHESIS_OPEN whitespace STRING_LITERAL whitespace PARENTHESIS_CLOSE
  ;

valueThresholdFilter
  :  THRESHOLD_FILTER_TYPE PARENTHESIS_OPEN whitespace valueThresholdFilterArgument whitespace PARENTHESIS_CLOSE
  ;

valueThresholdFilterArgument
  :  NUMBER
  |  IDENTIFIER
  ;

whitespace
  :  WHITESPACE*
  ;

mandatoryWhitespace
  :  WHITESPACE+
  ;

